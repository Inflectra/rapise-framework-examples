/*********************************************************************************
 * SmarteStudio is a GUI testing framework developed by
 * SmarteSoft, Inc. Copyright (C) 2008 - 2013 SmarteSoft Inc.
 *
 * The  copyright  to  the document(s)  herein  is  the property of     
 * SmarteSoft, Inc.                                                     
 * 
 * The document(s) may be used  and/or copied only with the written
 * permission from SmarteSoft, Inc.  or in accordance with
 * the terms  and conditions  stipulated in the  agreement/contract
 * under which the document(s) have been supplied.                      
 ********************************************************************************/

// Documented/pass1

/**
 * @fileOverview
 * This is a file defining common functions.
 */

/**
 * Version of object serialization schema.
 * @type Number
 */
var g_version = 0;

/**
 * Verbose level.
 * @type Number
 */
var g_verboseLevel = 2;

/**
 * Verbose level indicators. Should be set via "g_verboseLevel" parameter.
 * @ignore
 */
var l4=false;
var l3=false;
var l2=false;
var l1=false;
var l0=false;
var g_logToFile=false;

var g_logFileName="res.log";
var g_debug = false; // In debug mode exceptions are never caught. So that we can see them in debugger.

var g_enablePopupMessages=true;

/**
 * Thread is non-empty 
 */
var g_playerThread = "";

/**
 *  Default duration for mouse move in milliseconds. If you want mouse sliding set this value to 500 for example.
 */
var g_mouseMoveDuration=0;

/**
 * Reads command line arguments.
 */
function InitializeSeSEngine()
{
	var WshShell = new ActiveXObject("WScript.Shell");
	var _processEnv = WshShell.Environment("PROCESS");

	function _readArguments()
	{
		if(l2) Log2("Total arguments:"+WScript.Arguments.length);
		var objArgs = WScript.Arguments;
		for(var i=1;i<objArgs.length;i++)
		{
			if(l3) Log3(i+":"+objArgs(i));
			g_util.RegisterTestCmdParam(objArgs(i));
			var arg = objArgs(i);
			if(arg.indexOf("-eval:")==0)
			{
				var evalStr = arg.substring("-eval:".length);
				// Replacing double quotes placeholder $#dq#$ generated by RapiseLauncher in Rapise.cs::TestExecute (RapiseLauncher)
				evalStr = evalStr.replace(/\$\#dq\#\$/g, "\"");
				if(l2) Log2(""+evalStr);
				eval(evalStr);
			}
		}
	}
	
	function _initializeLogging()
	{
		for(var i=0;i<5;i++)
		{
			// Set all verbose levels
			if(i<=g_verboseLevel)
				eval("l"+i+"=true;"); 
			else
				eval("l"+i+"=false;"); 
		}
		Log("Verbose level:"+g_verboseLevel);
	}
	
	g_verboseLevel = 0;

	// Read command line
	_readArguments();
	
	g_playerThread = g_playerThread || _processEnv("THREAD");
	_processEnv("THREAD") = g_playerThread;

	// Initialize logging
	_initializeLogging();

	// Read command line
	_readArguments();
	
	g_helper.EnablePopupMessages(g_enablePopupMessages);

	if(g_recording)
	{
		SeSEnableScreenshots(g_saveRecordingScreenshots);
	} else {
		SeSEnableScreenshots(g_savePlaybackScreenshots);
	}
	
	
	// First, resolve paths that are normally set are relative to test, not to workdir
	
	
	g_workDir = g_helper.ResolveEnvironmentVariables(g_workDir);

	var fso = new ActiveXObject("Scripting.FileSystemObject");
	g_workDir = fso.GetAbsolutePathName(g_workDir)+ "\\";
	WshShell.CurrentDirectory = g_workDir;
	
	_processEnv("WORKDIR") = g_workDir;
	g_helper.RegisterIncludePath(g_workDir);

	if(g_playerThread)
	{
		// Don't show execution monitor in multi-threaded mode
		g_showExecutionMonitor=false;

		if( (g_reportFileName+"$").indexOf(g_playerThread+".trp$")<0 )
		{
			g_reportFileName = (g_reportFileName+"$").replace(".trp$", g_playerThread+".trp");
		}
	}
	
}

/**
 * Path to work directory. It is root folder of single test
 * or the whole test set (master test).
 * @type String
 */
 var g_workDir = ".\\";

/**
 * Name of a function that should be used as an entry point
 * @type String
 */
 var g_entryPointName = "Test";

/**
 * Path to file containing 'Test' entry point function
 * @type String
 */
var g_scriptFileName = "Recorded_Script.js";
/**
 * Path to a report file
 * @type String
 */
var g_reportFileName = g_scriptFileName+".trp";

/**
 * Path to a file with user-defined variables and functions
 * @type String
 */
var g_userFunctionsFileName = g_scriptFileName;

/**
 * Path to a file containing 'saved_script_objects'
 * @type String
 */
var g_scriptObjectsFileName = g_scriptFileName;

/**
 * Hash of all 'other' options. Good place to add 'custom' options for a give script.
 * @type Objects
 */
var g_options = {};

/**
 * This variable is set to 'true' when we are in recording mode.
 * @type Boolean
 */
var g_recording = false;

/**
 * If set to 'true' then Spy must be launched in Discovery Mode
 * @type Boolean
 */
var g_spyDiscoveryMode = false;

/**
 * Interval in milliseconds to wait between executing successive commands.
 * @type Number
 */
var g_commandInterval = 1000;

/**
 * If this variable is set to 'true' Tester.FailTest will be called on any failure 
 * (object not found, action failed and assertion failed).
 * @type Boolean
 */
var g_stopOnError = false;

/**
 * This variable is set to 'true' if object cache should be used to quickly find already located objects.
 * @type Boolean
 */
var g_cacheObjects = true;

/**
 * Object find attempts means number of times to search for a given object before giving up.
 * @type Number
 */
var g_objectLookupAttempts = 3;

/**
 * Time interval between attempts to find the same object if first attempt is failed.
 * @type Number
 */
var g_objectLookupAttemptInterval = 150;

/**
 * Pretty-print saved_script_objects after recording.
 * @type Boolean
 */
var g_beautifySavedObjects = true;

/**
 * If recorder should react for accessible events.
 * @type Boolean
 */
var g_skipAccessibleEvents = false;

/**
 * Threshold to be used to get B&W Images (0-100). See ImageWrapper.Get2Bit for 
 * more information
 * @type Number
 */
var g_bwThreshold = 50;

/**
 * This variable defines if SmarteStudio will highlight each recognized object
 * @type Boolean
 */
var g_highlight = false;

/**
 * This variable defines if SmarteStudio will highlight each recognized object during recording
 * @type Boolean
 */
var g_recordingHighlight = true;


/**
 * Brings AUT window to front (and restore from iconic state) in SeS('obj') if set to 'true'.
 * @type Boolean
 */
var g_bringAutToFront = false;

/**
 * Always try to restore the window (make it foreground) when object is found
 * @type Boolean
 */	
var g_restoreWindowToForeground = true;

/**
 * Semicolon-separated list of Plug Ins to load before recording/execution.
 * Example:
 * 	g_loadPlugIns="AdvancedLogger;Grid";
 *
 * forces 
 * Engine/PlugIns/AdvancedLogger.js
 *   and
 * Engine/PlugIns/Grid.js 
 * to be loaded before execution/recording.
 */
var g_loadPlugIns="";


/**
 * Contains information of modifier keys pressed at the moment of script start.
 * This may be useful to enable Shift+Record to select libraries or Ctrl+Record to select Application & Libraries
 * during Recording.
 */
var g_modifierKeys="";

/**
 * Enables smart object match features
 */
var g_aiEnable = false;

/**
 * Smart object match threshold
 */
var g_aiFplConfidence = 0.96;

/**
 * Show prompt to update changed locators
 */
var g_aiMergePromptEnable = true;

/**
 * @ignore
 */
RegExp.prototype.toJSON = function (filter) {
    return "/"+this.source+"/ig";
};

/**
 * Singleton. An instance of SeSWrappers.Util which is an entry point for all windows API access-related features.
 * @type SeSWrappers.Util
 */
var g_util=new ActiveXObject('SeSWrappers.Util');

/**
 * Hash of all known objects.
 * @type Map<String,SeSObject>
 * @ignore
 */
var g_objectList=new Object();// 

/**
 * Hash of all objects that were detected as not matching any object in the library.
 * @type Map<String,Boolean>
 * @ignore
 */
var g_noObjectList=new Object();

/**
 * Array of functions used to produce valid Unique String for the GUI object from a given UI Platform.
 * @type Array
 * @ignore
 */
var g_objectStringLocators=[];

/**
 * Array of all SeSMatcherRule rules.
 * @type Array
 * @ignore
 */
var g_rulesList=[];

/**
 * List of functions each taking obj as input returning array of SeSMatcherRule
 * that are worth matching for this object. Returned rules are to be matched right
 * after g_rulesToMatchLast and before g_rulesToMatchFirst
 * @type Array
 */
var g_ruleDetectors=[];

/**
 * All known SeSMatcherRule rules grouped in hash of arrays by SeSObject.role.
 * @type Map<String,Array>
 */
var g_rulesHashByRole=[];

/**
 * All known SeSMatcherRule rules grouped in hash of arrays by SeSObject.className.
 * @type Map<String,Array>
 */
var g_rulesHashByClassName=[];

/**
 * All known SeSMatcherRule rules grouped in hash of arrays by SeSObject.object_type.
 * @type Map<String,Array>
 */
var g_rulesHashByType=new Object();

/**
 * Subset of rules that may match anything. To be tried before any other rule.
 * @type Array
 */
var g_rulesToMatchFirst=[];

/**
 * Subset of rules that may match anything. To be tried after any other rule.
 * @type Array
 */
var g_rulesToMatchLast=[];


/**
 * Finds a rule by name. For example, findRule("Win32Button") will find SeSMatcherRule object that defines object_type "Win32Button".
 * @param nm name of a rule.
 * @returns rule object.
 */
function SeSFindRuleByType(/**string*/ nm) /**SeSMatcherRule*/
{
	var res = g_rulesHashByType[nm];
	if(res) return res;
	/**
	 * @ignore
	 */
	for(var i=0;i<g_rulesList.length;i++)
	{
		if(g_rulesList[i].object_type==nm) return g_rulesList[i];
	}
	return null;
}


/**
 * This function encodes the string so that it may be safely considered as a JSON-encoded string
 * and puts its contents into quotes.
 * @param string input string.
 * @returns JSON-encoded string.
 */
function JSONquote(/**string*/ string) /**string*/ {
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	escapeable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	gap,
	indent,
	meta = {    // table of character substitutions
		'\b': '\\b',
		'\t': '\\t',
		'\n': '\\n',
		'\f': '\\f',
		'\r': '\\r',
		'"' : '\\"',
		'\\': '\\\\'
	},
	rep;

	// If the string contains no control characters, no quote characters, and no
	// backslash characters, then we can safely slap some quotes around it.
	// Otherwise we must also replace the offending characters with safe escape
	// sequences.
	escapeable.lastIndex = 0;
	return escapeable.test(string) ?
		'"' + string.replace(escapeable, function (a) {
			var c = meta[a];
			if (typeof c === 'string') {
				return c;
			}
			return '\\u' + ('0000' +
					(+(a.charCodeAt(0))).toString(16)).slice(-4);
		}) + '"' :
		'"' + string + '"';
}

/**
 * In the learning process it is important to recognize objects that are already learned
 * and known. 
 * 
 * This function makes string representation of an object that allows distinguishing it from 
 * other objects. This way we may be sure that we don't learn the same object twice.
 *
 * The string representation is done in accordance to specific features of GUI platform that particular on screen object belongs to.
 *
 * Extension libraries extend this function with custom implementation by registering function in g_objectStringLocators array.
 *
 * @param ao instance of object to create unique string for.
 * @returns unique object identifier.
 */
function uniqueObjectString(/**SeSWrappers.AacWrapper*/ ao) /**string*/
{
	for(var sl=0;sl<g_objectStringLocators.length;sl++)
	{
		try {
			var res = g_objectStringLocators[sl](ao);
			if(res&&null!=res) return res;
		} catch(e){}
	}

	return _defaultUniqueObjectString(ao);
}

function _defaultUniqueObjectString(/**SeSWrappers.AacWrapper*/ ao) /**string*/
{
	if(null==ao) return "";
	var res = "";
	try
	{
		res = ao.Name+"/"+ao.GetRoleString()+"/";
		res+= ":loc:" + ao.PosX + ":" + ao.PosY; 
		var hwnd = ao.HWND;
		if(null!=hwnd) 
		{
			res+= ":" + hwnd.ClassName
		}
		var par = ao.Parent;
		if(null!=par) 
		{
			res+=":"+par.Name+"/"+par.GetRoleString()+"/";
			hwnd = par.HWND;
			if(null!=hwnd)
				res+= hwnd.ClassName
		}
	} catch(ex) {
		res = ""+(new Date())+Math.random();
	}
	return res;
}

/**
 * JavaScript objects are hashes. The field may be added as obj[kkk], where kkk is a field name. 
 * The problem here is that 'kkk' should be a valid JavaScript identifier, otherwise hash does not work.
 * 
 * This function takes any string and returns the string like 
 * 		_<md4> 
 * This guarantees that what we get is unique (due to md4) and valid (due to _) identifier.
 * @param str any string
 * @returns hash string.
 */
function fixForHash(/**string*/ str) /**string*/
{	
	return "_"+g_md4Helper.hex_md4(str);
}

/**
 * MD4 helper.
 * @ignore
 */
var g_md4Helper = new function()
{
	// We expect that g_helper is always defined. But this will avoid "Undefined" error in case we
	// are launching this .js file standalone to check if there are any syntax errors
	if("undefined"!=typeof(g_helper))
	{
		eval(g_helper.Include("md4.js"));
		this.hex_md4 = hex_md4;
	}
}

var g_sesScriptSerializerImpl=[];

/**
 * Find Class for the object of whatever kind
 */
function SeSScriptSerializer()
{
	for(var i in g_sesScriptSerializerImpl)
	{
		var res = g_sesScriptSerializerImpl[i]();
		if(res!==false) return res;
	}
	return SeSDefaultScriptSerializer();
}


/**
 * Produces SeSObject by matching screen widget using SeSObjectInfo provided.
 * This function takes all locations defined for a given widget and tries to apply them one-by-one
 * until success.
 * @param objInfo object info.
 * @returns matched {SeSObject} is returned; if none of locators matches, null is returned.
 */
function _SeSDeserializeObject(/**SeSObjectInfo*/ objInfo) /**SeSObject*/
{
	/**
	 * Helper function for _SeSDeserializeObject
	 * @ignore
	 */
	function _deserializeSeSObject(objInfo, obj)
	{
		var rule = SeSFindRuleByType(objInfo.object_type);
		
		if(!rule&&objInfo.library)
		{
			if(typeof(Tester)!="undefined")
			{
				Tester.Assert("Error resolving '"+objInfo.object_id+"': Library: '"+objInfo.object_library+"' not loaded! So it is impossible to locate object of type: "+objInfo.object_type);
			}
			return null;
		}
		
		if(rule&&null!=rule)
		{
			if(l2)Log2("Rule found");
			//if(rule.matchObject(obj))
			{
				if(l2)Log2("Matching the rule");
				var resObj = SeSTryMatch(obj, rule, objInfo);
				if(resObj)
				{

					if(objInfo.ignore_object_name||SeSCheckString(objInfo.object_name, resObj.name))
					{
						///!!!!!!!
						if(l2)Log2("Object deserialized!");
						if(!resObj.rule.dont_restore && g_restoreWindowToForeground)
						{
							var topWnd = resObj.getDesktopWindow();
							if(null!=topWnd)
							{
								topWnd.Restore();
							}
						}
						return resObj;
					} else {
						if(l2) Log2("Object found but name does not match. Expected: "+objInfo.object_name+" found:"+resObj.name);
					}
				}
			}
		}
		else
		{
			if(typeof(Tester)!="undefined")
			{
				Tester.Assert("Looking for rule: "+objInfo.object_type, false, "Probably library is not loaded for this rule");
			} else {
				Log("Unknown rule: "+objInfo.object_type+ ". Probably library is not loaded for this rule.");
			}
		}
		return null;
	}


	if(l2)Log2("Deserializing object:"+objInfo.object_type+"/"+objInfo.object_name);
	var resObj = null;
	if(objInfo&&objInfo.locations)
	{
		if(l2)Log2("Location found");
		for(var loc in objInfo.locations)
		{
			var locationObj = objInfo.locations[loc];
			if(typeof(g_flashObjectLocatorId)!="undefined" && g_flashObjectLocatorId)
			{
				Log("Looking for locator: #"+g_flashObjectLocatorId);
				if(loc!=g_flashObjectLocatorId) 
				{
					Log("skipping #"+loc);
					continue;
				}
			} else if("enabled" in locationObj) {
				if(!locationObj.enabled) continue;
			}
			
			
			if(l2)Log2("Location:"+loc+" Locator:"+locationObj.locator_name);
			var locator = findLocator(locationObj.locator_name);
			if(null!=locator)
			{
				if(l2)Log2("Locator found");
				var  obj = locator.fromLocation(locationObj.location, objInfo);
				if(obj&&null!=obj)
				{
					if(l2)Log2("Base object located");
					// Check what object do we have. If it is already a SeSObject,
					// Then we already have what we need.
					
					var isSeSObject=false;
					var isArray=false;
					try {
						// SeSObject always have object_type field. 
						// May need more elegant way to determine the type in the future
						if(obj.object_type) isSeSObject=true;
					} catch(e){}
					try {
						// SeSObject always have object_type field. 
						// May need more elegant way to determine the type in the future
						if(obj.length) isArray=true;
					} catch(e){}
					
					if(isSeSObject)
					{
						if(l2)Log2("Locator found final object:"+obj.toString());					
						return obj;
					} else if (isArray)
					{
						// This is an array of objects with given location
						if(l2)Log2("Found "+obj.length+" candidates");
						for(var index=0;index<obj.length;index++)
						{
							var objAtIndex = obj[index];
							resObj = _deserializeSeSObject(objInfo, objAtIndex);
							if (resObj)
								return resObj;
						}
					}
					else
					{
						// This is a single object with a given location
						if(l2)Log2("Found the only one candidate");
						resObj = _deserializeSeSObject(objInfo, obj);
						if (resObj)
							return resObj;
					}
				} else {
					if(l2)Log2("Base object not found by locator");				
				}	
			} else {
				var locMsg = "Object locator type unresolved: "+locationObj.locator_name;
				var msg = "Error resolving '"+objInfo.object_id+"': Library: '"+objInfo.object_library+"' not loaded! So it is impossible to locate object of type: "+objInfo.object_type;
			
				if(typeof(Tester)!="undefined")
				{
					Tester.Assert(msg, false, [
										locMsg,
										new SeSReportText("If you have this message from the Sub-Test, please make sure that g_load_libraries in the sub-test has same values as g_load_libraries in parent test.")
					]);
				} else {
					Log(locMsg);
					Log(msg);
				}
			
			}
		}
	}
	return null;
}


/**
 * Depending on 'exp' type this function does 
 * 1. exact comparison of strings when 'exp' is string
 * 2. regular expression match if 'exp' is RegExp
 * @param exp string or regular expression.
 * @param value string value to compare. 
 * @return 'false' when value is not equal and does not match exp, 'true' otherwise.
 */
function SeSCheckString(/**String|RegExp*/ exp, /**string*/ value) /**boolean*/
{
	return g_util.MatchString(exp, ""+value);
}

/**
 * Try to find AacWrapper that is currently at (x,y) position
 * @param x X position
 * @param y Y position
 */
function SeSGetAccessibleObjectAt(x,y)
{
	var ao = g_util.GetAccessibleObjectFromPoint(x,y);
	if(!ao)
	{
		var wnd = g_util.GetWindowFromPoint(x, y);
		if(wnd) ao = wnd.AccessibleObject;
	}
	return ao;
}


var g_sesGetObjectAtImpl=[SeSGetAccessibleObjectAt];

/**
 * Try to find AacWrapper that is currently at (x,y) position
 * @param x X position
 * @param y Y position
 */
function SeSGetAccessibleObjectUnderCursor()
{
	var wx = g_util.GetCursorX();
	var wy = g_util.GetCursorY();
	return SeSGetAccessibleObjectAt(wx, wy);
}

/**
 * Find an object of whatever kind at current cursor position
 */
function SeSGetObjectAt(x, y)
{
	for(var i in g_sesGetObjectAtImpl)
	{
		var res = g_sesGetObjectAtImpl[i](x,y);
		if(res) return res;
	}
	return null;
}


/**
 * Try to find role for this accessible object
 */
function SeSGetAccessibleObjectRole(/**SeSWrappers.AacWrapper*/obj)
{
	if(obj) return obj.GetRoleString();
	return "";
}


var g_sesGetObjectRoleImpl=[SeSGetAccessibleObjectRole];

/**
 * Find role for the object of whatever kind
 */
function SeSGetObjectRole(obj)
{
	for(var i in g_sesGetObjectRoleImpl)
	{
		var res = g_sesGetObjectRoleImpl[i](obj);
		if(res) return res;
	}
	return null;
}

/**
 * Try to find Class for this accessible object
 */
function SeSGetAccessibleObjectClass(/**SeSWrappers.AacWrapper*/obj)
{
	if(obj) return obj.HWND.ClassName;
	return "";
}


var g_sesGetObjectClassImpl=[SeSGetAccessibleObjectClass];

/**
 * Find Class for the object of whatever kind
 */
function SeSGetObjectClass(obj)
{
	for(var i in g_sesGetObjectClassImpl)
	{
		var res = g_sesGetObjectClassImpl[i](obj);
		if(res) return res;
	}
	return null;
}


/**
 * Find an object of whatever kind at current cursor position
 */
function SeSGetObjectUnderCursor()
{
	var wx = g_util.GetCursorX();
	var wy = g_util.GetCursorY();
	return SeSGetObjectAt(wx, wy);
}


/**
 * Puts object in cache.
 * @param ao accessible object.
 * @param autoMatchSimulated if no rule is satisfied then the object is considered as Simulated.
 * @returns matched object.
 */
function SeSCacheAccessibleObject(/**SeSWrappers.AacWrapper*/ ao, /**boolean*/autoMatchSimulated) /**SeSObject*/
{
	autoMatchSimulated = autoMatchSimulated||false;
	var ustrPlain = uniqueObjectString(ao);
	var ustr = fixForHash(ustrPlain);
	
	var so = g_objectList[ustr];
	var reload  = false;
	
	// We know that are unable to recognize this object
	if (g_noObjectList[ustr])
	{
		if(autoMatchSimulated)
		{
			delete g_noObjectList[ustr];
		} else {
			return null;
		}
	}
	
	if(null==so)
	{
		reload = true;
	}
	else if (so&&so.instance&&so.instance.HWND&&
			ao&&ao.HWND&&(so.instance.HWND.Handle != ao.HWND.Handle))
	{
			// Came over another instance of the same object
			if(l1)Log1("Reloading object:"+ustrPlain+"//"+ustr+" trying to learn...");
			reload = true;
	}

	if(reload)
	{
		if(l1)Log1("New object:"+ustrPlain+"//"+ustr+" trying to learn...");
		var res = null;
		if(g_debug)
		{
			res = SeSTryMatch(ao);
		} else {
			try
			{
				res = SeSTryMatch(ao);
			} catch(e) {
				Log("Error in SeSTryMatch:"+e.description);
			}
		}
		
		if(!res&&autoMatchSimulated)
		{
			res = SeSTryMatch(ao, SeSSimulatedObjectRule);
		}
		
		if(res)
		{
			if(g_objectList[ustr])
			{
				var robj = g_objectList[ustr];
				if(l1)Log1("Found!:"+robj+"::"+ustrPlain+"//"+ustr);
			
				// Remember that this object already has focus
				if (null==g_focusedObject && SeSIsFocused(robj))
				{
					g_focusedObject = robj; 
				}
			
				return robj;
			}
			else
			{
				// Caching the object as it actually appears after matching
				g_objectList[ustr] = res;
				
				return res;
			}
		} else {
			if(l1)Log1("Not found or unknown...");
			g_noObjectList[ustr] = true;
		}
	}
	else
	{
		// Tanur: Probably it is better to avoid it.
		// Stop highlighting whole window. We should better
		// rely on object's own highlight that will cover
		// more precise rectangle for a given control.
		//ao.HWND.Highlight();
	}
	return g_objectList[ustr];
}

var g_sesCacheObjectImpl=[SeSCacheAccessibleObject];

/**
 * Puts object in cache.
 * @param ao some object under cursor.
 * @param autoMatchSimulated if no rule is satisfied then the object is considered as Simulated.
 * @returns matched object.
 */
function SeSCacheObject(/**object*/ ao, /**boolean*/autoMatchSimulated) /**SeSObject*/
{
	for(var i=0;i<g_sesCacheObjectImpl.length;i++)
	{
		var res = g_sesCacheObjectImpl[i](ao, autoMatchSimulated);
		if(res) return res;
	}
	return null;
}


/**
 * Locates focused window and sets g_focusedObject to {SeSObject} currently having focus.
 * @returns focused {SeSObject} or null.
 */
 function SeSSetAccessibleFocusedObject()
{
	var hwndForeground = g_util.GetForegroundWindow();
	
	if(null!=hwndForeground&&hwndForeground.PID==g_wndProcId||hwndForeground.PPID==g_wndProcId)
	{
		var aoFocused = hwndForeground.AccessibleObject;
		
		if(aoFocused)
		{
			var soFocused = SeSCacheAccessibleObject(aoFocused, true);
			if( soFocused) 
			{
				g_focusedObject = soFocused;
			}
		}
	}
	return g_focusedObject;
}

var g_sesSetFocusedObjectImpl=[SeSSetAccessibleFocusedObject];

/**
 * Puts object in cache.
 * @param ao some object under cursor.
 * @param autoMatchSimulated if no rule is satisfied then the object is considered as Simulated.
 * @returns matched object.
 */
function SeSSetFocusedObject() /**SeSObject*/
{
	for(var i=0;i<g_sesSetFocusedObjectImpl.length;i++)
	{
		var res = g_sesSetFocusedObjectImpl[i]();
		if(res) return res;
	}
	return null;
}

/**
 * Global list of all known locator types. Used by "deserializeObject" to find appropriate locator for given locator name.
 * @type Array
 * @ignore
 */
var g_locatorsList = [];

/**
 * Finds the locator defined in g_locatorsList by its name.
 * @param nm locator name
 * @returns found {SeSObjectLocator} instance, null otherwise.
 */
function findLocator(/**string*/ nm) /**SeSObjectLocator*/
{
	for(var i=0;i<g_locatorsList.length;i++)
	{
		if(g_locatorsList[i].locator_name==nm) return g_locatorsList[i];
	}
	return null;
}

/**
 * Returns all or_rules and and_rules belonging to a given rule and collects them 
 * into 'result' array. The rules are collected recursively.
 * @param rule rule to collect all sub-rules
 * @param result array to be populated with found sub-rules
 * @ignore
 */
function _SeSGetAllRules(/**SeSMatcherRule*/ rule, /**array*/ result)
{
      result.push(rule);
      for (var i in rule.or_rules)
      {
         _SeSGetAllRules(rule.or_rules[i], result);
      }
      for (var i in rule.and_rules)
      {
         _SeSGetAllRules(rule.and_rules[i], result);
      }
}

/**
 * Entry point for matching IAccessible object.
 * All matching logic provided by SeSMatcherRule patterns is launched from here.
 * @param obj instance of IAccessible object.
 * @param rule rule to use for matching 'obj'.
 * @param objInfo additional information needed to instantiate an object
 * @returns {SeSObject} instance if match was successfull, 'false' otherwise.
 */
function SeSTryMatch(/**SeSWrappers.AacWrapper*/ obj, /**SeSMatcherRule*/ rule, /**object*/objInfo) /**SeSObject|false*/
{
	function _getMatchedObject(mo)
	{
		if(l1) Log1("MatchedObject:"+mo);
		if(mo)
		{
			g_util.SetStatus("Last captured: "+mo.object_type+" ("+mo.name+")");
			
			if( (g_recording&&g_recordingHighlight) || g_highlight) 
			{
				mo.highlight();
				if(l1)Log1("HighLighted");
			}
		}
		if(l2) Log2("SeSTryMatch finished in: "+ (new Date()-_st)+" [ms]");
		return mo;
	}

	var _st = new Date();
		
	var objRole = rule?rule.objectRole(obj):SeSGetObjectRole(obj);
	var objClass = rule?rule.objectClass(obj):SeSGetObjectClass(obj);
	var roleRules = g_rulesHashByRole[objRole];
	var classRules = g_rulesHashByClassName[objClass];

	if(l2) Log2("Role:"+objRole+" Class:"+objClass+" Role rules:"+(null!=roleRules?roleRules.length:0)+" Class rules:"+(null!=classRules?classRules.length:0));

	var objRules = [];
	if (!rule)
	{
		objRules=objRules.concat(g_rulesToMatchFirst);

		for(var rdi in g_ruleDetectors)
		{
			var rdfunc = g_ruleDetectors[rdi];
			objRules = objRules.concat(rdfunc(obj));
		}

		if(null!=roleRules) objRules=objRules.concat(roleRules);
		if(null!=classRules) objRules=objRules.concat(classRules);

		objRules=objRules.concat(g_rulesToMatchLast);
	}
	else
	{
		_SeSGetAllRules(rule, objRules);
	}

	if(objRules.length>0)
	{
		if(l2)Log2("We have: "+objRules.length+" rules defined for this role and classname");
		if (l3)
		{
			for(var i=0;i<objRules.length;i++)
			{
				Log3("Rule" + (i+1) + ": " + objRules[i]); //if
			}
		}
		for(var i=0;i<objRules.length;i++)
		{
			var mores = objRules[i].matchObject(obj);
			if(mores)
			{
				if(l1)Log1("************!!!!!!!!!!!!!!!!!!**************");
				var mo = null;
				if(g_debug)
				{
					mo = objRules[i].getMatchedObject(objInfo);
				} else {
					try
					{
						mo = objRules[i].getMatchedObject(objInfo);
					} catch(e) {
						Log("ERROR in SeSTryMatch/getMatchedObject/getMatchedObject:"+e.message);
						if(l2) Log2("SeSTryMatch failed in: "+ (new Date()-_st)+" [ms]");
					}
				}

				if(g_debug)
				{
						return _getMatchedObject(mo);
				} else {
					try
					{
						return _getMatchedObject(mo);
					}catch(e) {
						Log("ERROR in SeSTryMatch/getMatchedObject:"+e.message);
						if(l2) Log2("SeSTryMatch failed in: "+ (new Date()-_st)+" [ms]");
					}
				}
			} 
		}
	}
	g_util.SetStatus("Unknown: "+obj);
	if(l2) Log2("SeSTryMatch finished in: "+ (new Date()-_st)+" [ms]");
	return false;
}



/**
 * Logging-related functions. To be moved into SeSHelper.
 */

/**
 * @ignore
 */
function _SeSCurrMillis()
{
	var intMilliSecs = (new Date()).valueOf();
	return intMilliSecs;
}

/**
 * Level 0 logging function.
 * @param txt text to put in the log.
 */
function Log()
{
	var txt = "";
	var sep = "";
	for (var i = 0; i < arguments.length; i++) 
	{
		txt += sep+arguments[i];
		sep = " ";
	}


	if(l3) txt = _SeSCurrMillis()+":\t"+txt;
	if(l0)
	{
		WScript.Echo(""+txt);
	}
	if(g_logToFile) 
	{
		// appendLog(txt);
		g_helper.FileWrite(g_logFileName, txt+"\n");
	}
}

/**
 * Level 1 logging function.
 * @param txt text to put in the log.
 */
function Log1()
{
	Log.apply(null,arguments);
}

/**
 * Level 2 logging function.
 * @param txt text to put in the log.
 */
function Log2()
{
	Log1.apply(null,arguments);
}

/**
 * Level 3 logging function.
 * @param txt text to put in the log.
 */
function Log3(/**string*/ txt)
{
	Log2.apply(null,arguments);
}

/**
 * Level 4 logging function.
 * @param txt text to put in the log.
 */
function Log4(/**string*/ txt)
{
	Log3.apply(null,arguments);
}

if(typeof(console)=='undefined')
{
	console = {
		log:function(){
		    Log.apply(null,arguments);
		}
	};
}

/**
 * Sleeps for specified interval.
 * @param interval interval in milliseconds (1 second = 1000). Default value is 1000.
 */
function SeSSleep(/**number*/ interval)
{
	interval = interval||1000;
	var end = _SeSCurrMillis()+interval;
	
	while(_SeSCurrMillis()<end)
	{
		WScript.Sleep(10);
	}	
}

/**
 * Tells g_util about all known libraries. This will later be used to show all
 * available object types in "Learn" combobox.
 */
function InitAllLibraries()
{
	// Inform about all available libraries
	for(var i in g_all_libraries)
	{
		var bFound = false;
		for(var j in g_load_libraries)
		{
			var libname = SeSResolveLibraryName(g_load_libraries[j]);
			if(libname==g_all_libraries[i].name)
			{
				g_util.RegisterLibrary(g_all_libraries[i].name, g_all_libraries[i].description, true);
				bFound = true;
				break;
			}
		} 
		
		if(!bFound)
		{
			g_util.RegisterLibrary(g_all_libraries[i].name, g_all_libraries[i].description, false);
		}
	}
}

/**
 * This array contains all information for extended patterns. Should be set via 
 * call to "SeSExtendAction" function
 * @type Array
 * @ignore
 */
var g_extensionPatterns = [];

/**
 * @deprecated: use SeSOverrideAction
 * Overrides Behavior.
 * this may be used if some behavior should be tweaked.
 * @param 	objectType Either object_type of the rule or regexp pattern for object_type.
 * @param 	doActionName action name. For example "DoClick".
 * @param 	replacementFunction new action handler for specified action.
 * @returns 'true' if object_type is found and replacement is successfull, 'false' otherwise.
 */
function SeSExtendAction(/**string*/ rulePattern, /**string*/ doActionName, /**Function*/ replacementFunction)
{
	if(l2)Log2("Extending the pattern for all rules matching:"+rulePattern);
	
	try
	{
		var rule = SeSFindRuleByType(rulePattern);
		if(rule&&!rule.extensions) rule.extensions={};
		if(rule) rule.extensions[doActionName]=replacementFunction;
	} catch(e) {}
	
	g_extensionPatterns.push({rulePattern:rulePattern, doActionName:doActionName, replacementFunction:replacementFunction});	
	
	return true;
}

/**
 * Overrides Behavior.
 * this may be used if some behavior should be tweaked. Default action handler
 * is passed to the callback as the first parameter.
 * https://www.inflectra.com/support/knowledgebase/kb354.aspx
 * @param 	objectType Either object_type of the rule or regexp pattern for object_type.
 * @param 	actionName action name. For example "DoClick".
 * @param 	callback new action handler for specified action.
 * @returns 'true' if object_type is found and replacement is successfull, 'false' otherwise.
 */
function SeSOverrideAction(/**string*/ objectType, /**string*/ actionName, callback)
{
	var rule = SeSFindRuleByType(objectType);
	if (rule && rule.behavior)
	{
		var behaviors = [];
		
		var r = rule;
		while(r)
		{
			for(var bi = 0; bi < r.behavior.length; bi++)
			{
				var beh = r.behavior[bi];
				behaviors.push(beh);
			}
			if (r.extend_rule)
			{
				r = SeSFindRuleByType(r.extend_rule);
			}
			else
			{
				r = null;
			}
		}
	
		for(var bi = 0; bi < behaviors.length; bi++)
		{
			var beh = behaviors[bi];
			if (beh && beh.actions)
			{
				for(var ai = 0; ai < beh.actions.length; ai++)
				{
					var action = beh.actions[ai];
					if (("Do" + action.actionName) == actionName)
					{
						var defaultActionHandler = action.DoAction;
						action.DoAction = function()
						{
							var args = [defaultActionHandler];
							args.push.apply(args, arguments);
							return callback.apply(this, args);
						}
						return;
					}
				}
			}
		}
		
		// No default handler for this action
		if (behaviors.length > 0)
		{
			var beh = behaviors[0];
			if (!beh.actions)
				beh.actions = [];
			beh.actions.push({
				actionName: actionName.substr(2),
				DoAction: function()
				{
					var args = [];
					args.push.apply(args, arguments);
					return callback.apply(this, args);
				}
			});
		}
	}
}

/**
 * Check if projet's "subfolder" exist. If not it is created. 
 * then unique file name name<nnnn>.ext is detected.
 * @param subFolder Project subfolder to create a file (such as "Images" or "Reports")
 * @param name file name
 * @param ext file extension
 */
function SeSCreateProjectFileName(/**string*/subFolder, /**string*/name, /**string*/ext)
{
    var fso = new ActiveXObject("Scripting.FileSystemObject");
    var folderPath = subFolder;
    if(!fso.FolderExists(folderPath))
    {
        fso.CreateFolder(folderPath);
    }  

	var objFolder = fso.GetFolder(folderPath);

	var nn = 0;
	do
	{
		nn++;
		var fName = objFolder+"\\"+name+(""+(10000+nn)).substring(1)+"."+ext;
		if(fso.FileExists(fName)) continue;
		
		return subFolder+"\\"+name+(""+(10000+nn)).substring(1)+"."+ext;
	    
	} while(true);
	
	return "????";
}

/**
 * Extract function signature
 */
function _SeSExtractSignature(func)
{
	if(!func) return "";
	
	var fText = ""+func;
	var start = fText.indexOf("(");
	var end = fText.indexOf(")");
	var len = end-start;
	if(len<0) return "";
	var res = fText.substring(start+1, end);
	return res;
}

function _SeSProcessParamInfoText(pTxt)
{
	if(typeof(pTxt)=="function")
	{
		var fullTxt = ""+pTxt;
		// Parse function body, extract and format comment
		var commentBegin = fullTxt.indexOf("/**");
		if(commentBegin < 0)
			return fullTxt;
		var commentEnd = fullTxt.indexOf("*/", commentBegin + 3);
		if(commentEnd < 0)
			return fullTxt;
		var comment = fullTxt.substring(commentBegin + 3, commentEnd);
		comment = comment.replace(/^[\t ]*\* {0,1}/gm, "");
		comment = comment.replace(/(^\s+)|(\s+$)/g, ""); // trim
		return comment;
	}
	
	return ""+pTxt;
}

/**
 * Create Object info by prototype
 */
function _SeSMakeObjectInfo(prot)
{
	var res = {
		window_name: "Global Objects",
		flavor: "GlobalObject"
	};

	if(prot.prototype._objectInfo)
	{
		for(var j in prot.prototype._objectInfo)
		{
			res[j] = prot.prototype._objectInfo[j];
		}
	}

	var actions = [];
	for(var k in prot.prototype)
	{
		// Save information about all functions having "_paramInfo<funcName>" member defined.
		if( (""+k).indexOf("_paramInfo")==0 )
		{	
			var actName = (""+k).substr("_paramInfo".length);
			if(typeof(prot.prototype[actName])=='function')
			{
				var rparams ={};
				var description ="";
				var type = "";
				var returns = "";
				for(var pp in prot.prototype[k])
				{
					if( "_"==(""+pp) || "_description"==(""+pp)) 
					{
						description = _SeSProcessParamInfoText(prot.prototype[k][pp]);
					}
					else if ("_type"==(""+pp))
					{
						type = prot.prototype[k][pp];
					}
					else if ("_returns"==(""+pp))
					{
						returns = prot.prototype[k][pp];
					}
					else {
						rparams[pp]=prot.prototype[k][pp];
					}
				}
			
				actions.push(
					{
						name: actName,
						description: description,
						type: type,
						returns: returns,
						signature: _SeSExtractSignature(prot.prototype[actName]),
						paramInfo: rparams
					}
				);
			}
		}
	}
	res.actions = actions;
	
	return res;
}

/**
 * Libraries may add their own handlers to process accessible events before SeSRegisterAccessibleEvent.
 * Handler signature should be the same as of SeSRegisterAccessibleEvent. Handler should return 
 * 'true' if the event was consumed, 'false' - otherwise. If the event was consumed by one of the custom
 * handlers then SeSRegisterAccessibleEvent is not invoked.
 */
var g_customEventHandlers = [];
 
function _SeSIsValidObject(ao)
{
	if(g_wndProcId == ao.HWND.PID || g_wndProcId == ao.HWND.PPID)
	{
		if(ao.GetRoleString() != "ROLE_SYSTEM_CARET") 
		{
			return true;
		}
	}
	return false;
}

/**
Regexp to match all invalid JavaScript Identifiers (including possible Unicode values)

By valid identifier we assume:

a-zA-Z0-9_$

AND following:

UnicodeCategory.CurrencySymbol
\u0024\u00a2-\u00a5\u09f2\u09f3\u0e3f\u17db\u20a0-\u20af\ufe69\uff04\uffe0\uffe1\uffe5\uffe6
UnicodeCategory.ConnectorPunctuation
\u005f\u203f\u2040\u30fb\ufe33\ufe34\ufe4d-\ufe4f\uff3f\uff65
UnicodeCategory.LetterNumber 
\u2160-\u2183\u3007\u3021-\u3029\u3038-\u303a
UnicodeCategory.NonSpacingMark
\u0300-\u034e\u0360-\u0362\u0483-\u0486\u0591-\u05a1\u05a3-\u05b9\u05bb-\u05bd\u05bf\u05c1\u05c2\u05c4\u064b-\u0655\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u0901\u0902\u093c\u0941-\u0948\u094d\u0951-\u0954\u0962\u0963\u0981\u09bc\u09c1-\u09c4\u09cd\u09e2\u09e3\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a70\u0a71\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0b01\u0b3c\u0b3f\u0b41-\u0b43\u0b4d\u0b56\u0b82\u0bc0\u0bcd\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0cbf\u0cc6\u0ccc\u0ccd\u0d41-\u0d43\u0d4d\u0dca\u0dd2-\u0dd4\u0dd6\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032\u1036\u1037\u1039\u1058\u1059\u17b7-\u17bd\u17c6\u17c9-\u17d3\u18a9\u20d0-\u20dc\u20e1\u302a-\u302f\u3099\u309a\ufb1e\ufe20-\ufe23

*/

var g_invalidJavaScriptIdRegex=/[^a-zA-Z0-9_\$\u0024\u00a2-\u00a5\u09f2\u09f3\u0e3f\u17db\u20a0-\u20af\ufe69\uff04\uffe0\uffe1\uffe5\uffe6\u005f\u203f\u2040\u30fb\ufe33\ufe34\ufe4d-\ufe4f\uff3f\uff65\u2160-\u2183\u3007\u3021-\u3029\u3038-\u303a\u0300-\u034e\u0360-\u0362\u0483-\u0486\u0591-\u05a1\u05a3-\u05b9\u05bb-\u05bd\u05bf\u05c1\u05c2\u05c4\u064b-\u0655\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u0901\u0902\u093c\u0941-\u0948\u094d\u0951-\u0954\u0962\u0963\u0981\u09bc\u09c1-\u09c4\u09cd\u09e2\u09e3\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a70\u0a71\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0b01\u0b3c\u0b3f\u0b41-\u0b43\u0b4d\u0b56\u0b82\u0bc0\u0bcd\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0cbf\u0cc6\u0ccc\u0ccd\u0d41-\u0d43\u0d4d\u0dca\u0dd2-\u0dd4\u0dd6\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032\u1036\u1037\u1039\u1058\u1059\u17b7-\u17bd\u17c6\u17c9-\u17d3\u18a9\u20d0-\u20dc\u20e1\u302a-\u302f\u3099\u309a\ufb1e\ufe20-\ufe23]/ig;

function _SeSMakeValidIdentifier(rName)
{
	function isDigit(chr)
	{
		return ((chr  >= "0") && (chr  <= "9"));
	}
	
	rName=rName.replace(/\+/g, "Plus");
	rName=rName.replace(/\-/g, "_");
	rName=rName.replace(/\*/g, "Star");
	rName=rName.replace(/\&/g, "N");
	rName=rName.replace(/\%/g, "Percent");
	rName=rName.replace(g_invalidJavaScriptIdRegex, "_");
	if( rName && (""+rName).length>0 )
	{
		if(isDigit(rName.charAt(0)))
		{
			rName="_"+rName;
		}
	}
	
	return rName;
}

function _SeSMakeSaveObjectId(rName)
{
	switch((""+rName).toLowerCase())
	{
		case "var":
		case "null":
		case "new":
		case "function":
		case "object":
		case "nan":
		case "parseint":
		case "parsefloat":
		case "delete":
		case "throw":
		case "catch":
		case "as":
		case "in":
		case "break":
		case "switch":
		case "for":
		case "while":
		case "if":
		case "else":
		case "return":
		case "this":
		case "typeof":
		case "var":
		case "void":
		case "with":
		case "abstract":
		case "boolean":
		case "byte":
		case "case":
		case "catch":
		case "char":
		case "class":
		case "const":
		case "debugger":
		case "default":
		case "do":
		case "double":
		case "enum":
		case "export":
		case "extends":
		case "final":
		case "finally":
		case "float":
		case "goto":
		case "implements":
		case "import":
		case "instanceof":
		case "int":
		case "interface":
		case "long":
		case "native":
		case "package":
		case "private":
		case "protected":
		case "public":
		case "short":
		case "static":
		case "super":
		case "switch":
		case "synchonizer":
		case "throws":
		case "transient":
		case "try":
		case "volatile":
		case "number":
		case "math":
		case "date":
			rName = "_"+rName;
			break;
	}
	
	try
	{
		var metadataPath = ''+g_helper.GetEnginePath()+'\\Metadata\\GlobalObjects\\'+rName+'.metadata';
		if (g_helper.FileExists(metadataPath))
		{
			rName =  "_"+rName;
		}
	}catch(e){}
	
	return rName;
}

function _SeSDoClick(clickType)
{
	clickType = clickType || "";

	switch(clickType.toUpperCase())
	{
	case "":
	case "L":
		g_util.LClick();
		break;
	case "LD":
		g_util.LDClick();
		break;
	case "R":
		g_util.RClick();
		break;
	case "RD":
		g_util.RDClick();
		break;
	case "M":
		g_util.MClick();
		break;
	case "MD":
		g_util.MDClick();
		break;
	case "N":
		break;
	default:
		g_util.LClick();
	}
}
/**
 * Check if given window belongs to one of known web browsers (IE/FF/Chrome)
 */
function SeSIsWebBrowser(/**HWNDWrapper*/hwnd)
{
	if(null!=hwnd)
	{
		var processName = hwnd.ProcessName;
		if(processName.toLowerCase().indexOf("iexplore.exe")>=0) return true;
		if(processName.toLowerCase().indexOf("firefox.exe")>=0) return true;
		if(processName.toLowerCase().indexOf("chrome.exe")>=0) return true;
	}
	return false;
}

/**
 * Check if given rectangle belongs to a specific window.
 * In case that element completely fits window, its rectangle is returned
 * if there is only overlapping or scrollbar may hide a part of the rectangle
 * then rectangle object is returned with one field added: partial: true
 * I.e.:
 * input elRect: {x:1, y:2, w: 3, h: 4}
 * output: {x:1, y:2, w: 3, h:4, partial: true}
 * If rectangles don't overlap then null is returned
 */
function SeSValidateRectInWindow(hwnd, elRect)
{
	if(
		elRect
		&&
		typeof(elRect.x)=="number"&&typeof(elRect.y)=="number"&&typeof(elRect.w)=="number"&&typeof(elRect.h)=="number"
		&&
		elRect.w>0&&elRect.h>0
		&&
		elRect.y <= hwnd.PosY+hwnd.PosHeight
		&&
		elRect.x <= hwnd.PosX+hwnd.PosWidth
		&&
		(elRect.y+elRect.h) >= hwnd.PosY
		&&
		(elRect.x+elRect.w) >= hwnd.PosX
	)
	{
		elRect.partial=false;
		var vScroll = 20;
		var hScroll = 20;
		
		if(
			(elRect.x+elRect.w) >= (hwnd.PosX+hwnd.PosWidth-hScroll)
			||
			(elRect.y+elRect.h) >= (hwnd.PosY+hwnd.PosHeight-vScroll)
		)
		{
			elRect.partial=true;
		}

		if(
			elRect.x <= hwnd.PosX
			||
			elRect.y <= hwnd.PosY
		)
		{
			elRect.partial=true;
		}
	
		return elRect;
	}
	return null;
}

/**
 * Create metadata after recording. List of global objects is specified
 * by param generateGlobalObjects
 * 
 * @type Number
 */
function SeSGenerateGlobalObjectMetadata(generateGlobalObjects)
{
	for(var i=0;i<generateGlobalObjects.length;i++)
	{
		var globalInfo = {};
		var prot = null;
		try
		{
			eval("var prot = "+generateGlobalObjects[i].prot+";");
		} catch(e) {
			var incl = "";
			if(generateGlobalObjects[i].include)
			{
				incl = g_helper.Include(generateGlobalObjects[i].include);
			}
			eval(incl);
			eval("var prot = "+generateGlobalObjects[i].prot+";");
		}
		var oname = generateGlobalObjects[i].name;
		globalInfo[oname] = _SeSMakeObjectInfo(prot);

		var globalInfoFileName = g_helper.GetEnginePath()+"/Metadata/GlobalObjects/"+oname+".metadata";
		var resGlobalInfo = JSON.stringify(globalInfo,null,'\t');
		Log(globalInfoFileName);
		if(typeof(Tester)!="undefined")
		{
			Tester.Message(globalInfoFileName);
		}

		g_util.SaveUTF8(globalInfoFileName, resGlobalInfo);
	}
}

/**
 * Splits object location into its parts, ignoring separators that are in quotes (' and ")
 * 
 * @type Array
 */
function _SeSSplitLocation(location, sep)
{
	sep = sep||'.';
	var insideQuotes = false;
	var quotesType = '';
	
	var result = [];
	var part = '';
	var i = 0;
	while (i < location.length)
	{
		var ch = location.charAt(i);
		if (insideQuotes && ch == quotesType)
		{
			insideQuotes = false;
			quotesType = '';
		}
		else if (!insideQuotes && (ch == '"' || ch == "'"))
		{
			insideQuotes = true;
			quotesType = ch;
		}
		else if (!insideQuotes && ch == sep)
		{
			result.push(part);
			part = '';
		}
		else
		{
			part += ch;
		}
		i++
	}
	
	if (part != '')
	{
		result.push(part);
	}
	
	return result;
}

var g_sesOnActionRecordedImpl=[];
function  SeSOnActionRecording(/**SeSObject*/ obj, /**string*/ item, /**string*/ action, /**object*/ param, /**string*/ descr, /**boolean*/override, /**boolean*/show)
{
	for(var i in g_sesOnActionRecordedImpl)
	{
		var res = g_sesOnActionRecordedImpl[i](/**SeSObject*/ obj, /**string*/ item, /**string*/ action, /**object*/ param, /**string*/ descr, /**boolean*/override, /**boolean*/show);
		if(res) return res;
	}
	return false;
}

//#region Screenshots
/**
 * Save screen images for each action into Recording\<Date&Time> subfolder of the current test
 * @type Boolean
 */
 var g_saveRecordingScreenshots = false;
 
/**
 * Save screen images for each recognized objects (or desktop when object not found) into Repots\<Date&Time> subfolder of the current test
 * Screen images are also added to the test report.
 * @type Boolean
 */ 
var g_savePlaybackScreenshots = false;

/**
 * Save screenshots before interacting with the object.
 * @type Boolean
 */
var g_savePlaybackScreenshotsBeforeAction = false;
/**
 * Save screenshots after interacting with the object.
 * @type Boolean
 */
var g_savePlaybackScreenshotsAfterAction = true;


/**
 * Append screenshots into the test report (may increase size of the report)
 * @type Boolean
 */ 
var g_savePlaybackScreenshotsInTestReport = true;

/**
 * Defines either make screenshot for the object rectangle only (true) or for the whole window (false)
 * @type Boolean
 */ 
var g_saveScreenshotObjectOnly = true;

/**
 * Save index of all screenshots made by SeSObjectScreenshot into Report/<Date>/index.html or Recording/<Date>/index.html
 * @type Boolean
 */ 
var g_saveScreenshotsIndexHtml = true;

/**
 * Ordinal number of the screenshot current screenshot. Auto-incrementing in SeSObjectScreenshot
 * @type Boolean
 */ 
var g_saveScreenshotsObjectStepId = 1;

/**
 * Capture cursor with screenshot image
 * @type Boolean
 */ 
var g_saveScreenshotsCaptureCursor = true;

/**
 * Specify cursor capturing type (0 - no cursor, 1 - original cursor, 2 - special cursor marker)
 * @type Number
 */ 
var g_saveScreenshotsCaptureCursorType = 1;

/**
 * Defines either show execution monitor(true) or not(false)
 * @type Boolean
 */ 
var g_showExecutionMonitor = g_util.GetEngineSettings().EnableExecutionMonitor;


/**
 * Path for saving images and index.html. If not defined then set automatically in SeSObjectScreenshot
 * @type String
 */ 
var g_saveScreenshotsReportHtmlPath = null;

/**
 * Since we disabled flex but some places may still check its presense then hardcode
 * disabled flex here.
 */
var g_flex = false;

function SeSCaptureImageDefaultImpl(X, Y, W, H, saveScreenshotsCaptureCursor)
{
	if(!W&&!H)
	{
		// No width, heigth - capture whole desktop
		var /**HWNDWrapper*/desktopWnd = g_util.GetDesktopWindow(); 
		X = desktopWnd.PosX;
		Y = desktopWnd.PosY;
		W = desktopWnd.PosWidth;
		H = desktopWnd.PosHeight;
	}
	
	if(l3) Log3('Capturing: X: '+X+' Y: '+Y+' W: '+W+' H: '+H);
	for(var i=0;i<5;i++)
	{
		try
		{
			var img = new ActiveXObject("SeSWrappers.Utils.ImageWrapper");
			img.Capture(X, Y, W, H, saveScreenshotsCaptureCursor);
			return img;
		}catch(e){
			if(l3)Log3("Error trying ("+i+") to make a screenshot: "+e.message);
			Global.DoSleep( 1000*(i+1) );
		}
	}
	var img = new ActiveXObject("SeSWrappers.Utils.ImageWrapper");
	img.Capture(X, Y, W, H, saveScreenshotsCaptureCursor);
	return img;
}


var g_screenFlowHistory={filename:"", title:"", steps:[{id:0,txtLabel:"",imgPath:""}]};

/**
 *
 * @param obj object to make screenshot from. If it is null or undefined screenshot for the whole desktop.
 * @param txtLabel message to put 
 */
function SeSObjectScreenshot(/**SeSObject*/obj, /**string*/txtLabel, /**SeSMatcherRule*/rule, /**boolean*/ override)
{
	function _writeScreenHistory()
	{
		if( g_recording )
		{
			g_helper.DeleteFile(g_screenFlowHistory.filename);
		}
		
		if( g_recording || g_screenFlowHistory.steps.length==0 )
		{
			g_helper.FileWrite(g_screenFlowHistory.filename, "<h1>"+g_screenFlowHistory.title+"</h1>\n");
		}
		
		for( var i=0;i<g_screenFlowHistory.steps.length; i++)
		{
			if( !g_recording && i<g_screenFlowHistory.steps.length-1 ) continue;
			var step = g_screenFlowHistory.steps[i];
			g_helper.FileWrite(g_screenFlowHistory.filename, "<h3>"+step.id+": "+step.txtLabel+"</h3>\n<img src='"+step.imgPath+"'/>\n");
		}
	}


	if( override && g_saveScreenshotsObjectStepId>0 ) 
	{
		g_saveScreenshotsObjectStepId--;
		g_screenFlowHistory.steps.pop();
	}
	
	if(l2)Log2("Saving screen:"+g_saveScreenshotsObjectStepId);
	var img = null;
	
	var captureImpl = SeSCaptureImageDefaultImpl;
	if(rule&&rule.captureBitmap)
	{
		captureImpl = rule.captureBitmap;
	} else if(obj&&!obj.IsMissing&&obj.rule&&obj.rule.captureBitmap) {
		captureImpl = obj.rule.captureBitmap;
	}
  
  	var saveScreenshotsCaptureCursor = g_saveScreenshotsCaptureCursor?g_saveScreenshotsCaptureCursorType:0;
  
	if(g_saveScreenshotsIndexHtml&&!g_saveScreenshotsReportHtmlPath)
	{
		var strDateTime = UtilGetPaddedZeroesDateTime(new Date(), "_");
 
 		var title = "";
 		if(!g_recording)
 		{
			g_saveScreenshotsReportHtmlPath = Global.GetFullPath('Reports\\'+strDateTime);
			title = "Execution "+strDateTime;
			Tester.Message('Screen flow', new SeSReportLink(g_saveScreenshotsReportHtmlPath+"\\index.html"));
		} else {
			g_saveScreenshotsReportHtmlPath = 'Recording\\'+strDateTime;
			title = "Recording "+strDateTime;
			SeSRegisterIDETask("addfile", {folder:g_saveScreenshotsReportHtmlPath, path: g_saveScreenshotsReportHtmlPath+"\\index.html"}, null, function(){ });
		}
 
 		g_screenFlowHistory.filename = g_saveScreenshotsReportHtmlPath+"\\index.html";
 		g_screenFlowHistory.title =  title;
 		g_screenFlowHistory.steps = [];
 		 
		g_helper.CreateFolder(g_saveScreenshotsReportHtmlPath);

 		_writeScreenHistory(); 
	}
 
	if(!obj||obj.IsMissing||!obj.instance)
	{
 		txtLabel = txtLabel||"Desktop";
 
		img = captureImpl(0, 0, 0, 0, saveScreenshotsCaptureCursor);
		Tester.Message(txtLabel, new SeSReportImage(img, "Desktop"), {screen: g_saveScreenshotsObjectStepId});
 
		if(g_saveScreenshotsIndexHtml)
		{
			var strImgName = "Step"+g_playerThread+g_saveScreenshotsObjectStepId+".png";
			
			g_screenFlowHistory.steps.push({id:g_saveScreenshotsObjectStepId, txtLabel:txtLabel, imgPath: strImgName});
	 		_writeScreenHistory();

			
			img.Save(g_saveScreenshotsReportHtmlPath+"\\"+strImgName);
		}
		// Important: image is not available anymore.
		img.Dispose();
 
	} else {
		try
		{
			if (!txtLabel)
			{
				var objId = obj.object_id||"\"\"";
				var objName = obj.object_name||obj.object_id||obj.name||"\"\"";
				txtLabel = ("Id: "+ objId + " Name: " + objName);				
			}
 			
 			if(obj._cached_screenshot)
 			{
 				img = obj._cached_screenshot;
 				// Img is about to be disposed
 				obj._cached_screenshot = null;
 			} else {
				if(g_saveScreenshotObjectOnly)
				{
					var objX = obj.GetX();
					var objY = obj.GetY();
					var objW = obj.GetWidth();
					var objH = obj.GetHeight();
					if (l3) Log3("Widget screen coordinates: " + objX + ", " + objY + ", " + objW + ", " + objH);
					img = captureImpl(objX, objY, objW, objH, saveScreenshotsCaptureCursor);
				} else {
					img = captureImpl(0, 0, 0, 0, saveScreenshotsCaptureCursor);
				}
 			}
 			
			if(g_savePlaybackScreenshotsInTestReport&&!g_recording)
			{
				Tester.Message(txtLabel, new SeSReportImage(img, txtLabel), {screen: g_saveScreenshotsObjectStepId});
			}
			
			if(g_saveScreenshotsIndexHtml)
			{
				var strImgName = "Step"+g_playerThread+g_saveScreenshotsObjectStepId+".png";
				
				g_screenFlowHistory.steps.push({id:g_saveScreenshotsObjectStepId, txtLabel:txtLabel, imgPath: strImgName});
				_writeScreenHistory();
				
				var strScreenshotPath = g_saveScreenshotsReportHtmlPath+"\\"+strImgName;
				img.Save(strScreenshotPath);
				if(obj)
				{
					obj.screenshot_path = strScreenshotPath;
				}
			}
			
			// Important: image is not available anymore.
			img.Dispose();
			
		} catch(e) {
			if (l1) Log1("Error making screenshot: " + e.message);
		}
	}
	g_saveScreenshotsObjectStepId++;
	
	return obj;
}

function _SeSCacheObjectScreenshots(/**SeSObject*/ obj, /**object*/objRect, /**HWNDWrapper*/topWnd)
{
	if(g_recording&&!g_saveRecordingScreenshots) return;
	
	if(l2)Log2("Saving screen:"+g_saveScreenshotsObjectStepId);
	var img = null;
  	var saveScreenshotsCaptureCursor = g_saveScreenshotsCaptureCursor?g_saveScreenshotsCaptureCursorType:0;

	var captureImpl = SeSCaptureImageDefaultImpl;
	if(this.rule&&this.rule.captureBitmap)
	{
		captureImpl = this.rule.captureBitmap;
	} 

	if(g_saveScreenshotObjectOnly)
	{
		if(objRect)
		{
			img = captureImpl(objRect.x, objRect.y, objRect.w, objRect.h, saveScreenshotsCaptureCursor);
		} else {
			img = captureImpl(obj.GetX(), obj.GetY(), obj.GetWidth(), obj.GetHeight(), saveScreenshotsCaptureCursor);
		}
		obj._cached_screenshot =  img;
	} else {

		img = captureImpl(0,0,0,0, saveScreenshotsCaptureCursor);
		obj._cached_screenshot =  img;
	}
	
}

/**
 * Automatically save screenshot for recognized object if g_savePlaybackScreenshots is true. This function
 * simply replaces standard function SeS for all kind of objects.
 * @param obj passed to SeS function (object id)
 * @param [params] passed to SeS function (object recognition parameters)
 */
function SeSWithScreenshots(/**string*/ obj, /**params*/params) /**SeSObject*/
{
	var res = g_ses_withoutScreenshots(obj, params);

	try
	{
		var label = obj;
		if(!res||res.IsMissing)
		{
			label = "Object not found: "+obj;
			
			var oinf = _SeSGetObjectInfo(obj);
			var rule = SeSFindRuleByType(oinf.object_type);

			SeSObjectScreenshot(res, label, rule);
			if(g_recording)
			{
				res.highlight();
			}
		}
	} catch(e) {
		Log("Error making screenshot for: "+obj+" :"+e.message);
	}
	return res;
}

var g_ses_withoutScreenshots = null;

if(typeof(SeS)!="undefined")
{
	g_ses_withoutScreenshots = SeS;
}

function _SeSRemoveArrayItem(/**array*/arr,item)
{
	for(var i=0; i<arr.length; i++)
	{
		if(arr[i]==item)
		{
			arr.splice(i,1)
			return true;
		}
	}
	return false;
}

/**
 * Enable/Disable automated object image collection
 * @param [enable] - pass "false" to disable screenshot collection, otherwise pass "true" or no parameter 
 */
function SeSEnableScreenshots(enable)
{
	if(enable || typeof(enable)=="undefined")
	{
		if(g_recording)
		{
			g_sesOnActionRecordedImpl.push(_SeSMakeScreenshotOnActionRecording);
		} else {
			if(g_ses_withoutScreenshots)
			{
				g_sesOnBeforeActionExecutedImpl.push( _SeSMakeScreenshotBeforeAction );
				g_sesOnAfterActionExecutedImpl.push( _SeSMakeScreenshotAfterAction );
				SeS = SeSWithScreenshots;
				return true;
			} else {
				return false;
			}			
		}	
	} else {
		SeS = g_ses_withoutScreenshots;

		_SeSRemoveArrayItem(g_sesOnActionRecordedImpl, _SeSMakeScreenshotOnActionRecording);
		_SeSRemoveArrayItem(g_sesOnBeforeActionExecutedImpl, _SeSMakeScreenshotBeforeAction);
		_SeSRemoveArrayItem(g_sesOnAfterActionExecutedImpl, _SeSMakeScreenshotAfterAction);		
	}
}

/**
 * Automatically save screenshot for each recorded action 
 * if g_saveRecordingScreenshots is set to true.
 */
function _SeSMakeScreenshotOnActionRecording(obj,item,action,param,descr,override,show)
{
	if(obj&&(obj instanceof SeSObject))
	{
		SeSObjectScreenshot(obj, descr, null, override);
	}
	return false;
}


function _SeSMakeScreenshotAfterAction(/**SeSObject*/ obj, /**string*/ actionName, /**array*/ arguments, /**boolean*/ result)
{
	if(!g_savePlaybackScreenshotsAfterAction) {
		return;
	}
	var objName = obj.object_name||obj.object_id||obj.name||"\"\"";
	var status = result;
	if(result&&result.IsDoActionResult)
	{
		status = result.status;
		if(result.additional_value) 
		{
			result = result.additional_value;
		}
	}
	
	var statusStr = "";
	if(!status)
	{
		statusStr = "Fail: ";
	}

	// Callback on after action executed
	var actionString = statusStr+objName+".Do"+actionName+"("+JSON.stringify(arguments)+") returned "+result;

	SeSObjectScreenshot(obj, actionString);
}

function _SeSMakeScreenshotBeforeAction(/**SeSObject*/ obj, /**string*/ actionName, /**array*/ arguments)
{
	if(!g_savePlaybackScreenshotsBeforeAction) {
		return;
	}

	var objName = obj.object_name||obj.object_id||obj.name||"\"\"";
	// Callback on after action executed
	var actionString = "Before calling "+objName+".Do"+actionName+"("+JSON.stringify(arguments)+")";

	SeSObjectScreenshot(obj, actionString);

	// Should always return some result. In most cases same result as passed in.	
	return false;
}

//#endregion

/**
 * Escapes raw text to use inside a regular expression.
 */
function _SeSEscapeRegExp(text) 
{
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
} 

var g_knownInstrumentedFiles={};
var g_currentStatementInfo={};
function SeSRegisterJSStatement(fileInfo, fromLine, fromChar, toLine, toChar, txt)
{
	if(typeof fileInfo!='string')
	{
		// First statement in the file: _$R$_([shortPath, fullPath]);
		// - an array, then all statements are marked with shortPath
		g_knownInstrumentedFiles[fileInfo[0]]=fileInfo[1];
	}
	
	g_currentStatementInfo = {f:fileInfo, fl: fromLine, fc: fromChar, tl: toLine, tc: toChar, s: txt};
	
	if(l2) Log2("> "+g_currentStatementInfo.s);
}
var _$R$_ = SeSRegisterJSStatement;

function SeSGetCurrentStatementInfo()
{
	if(g_currentStatementInfo&&g_currentStatementInfo.f)
	{
		var fn = g_currentStatementInfo.f;
		fn = g_knownInstrumentedFiles[fn] || fn;
		
		return fn+" ("+g_currentStatementInfo.fl+","+g_currentStatementInfo.fc+"):\nExecuting:\n"+g_currentStatementInfo.s;
	}
	return "";
}

function SeSGetCurrentStatementReportData()
{
	if(g_currentStatementInfo&&g_currentStatementInfo.f)
	{
		var fn = g_currentStatementInfo.f;
		fn = g_knownInstrumentedFiles[fn] || fn;
		var pos = fn+"("+g_currentStatementInfo.fl+","+g_currentStatementInfo.fc+")";
		return [new SeSReportLink(pos), new SeSReportText(g_currentStatementInfo.s)];
	}
	return null;
}

function SeSReportExceptionStatement(e, comment)
{
	if(g_currentStatementInfo&&g_currentStatementInfo.f)
	{
		var fn = g_currentStatementInfo.f;
		fn = g_knownInstrumentedFiles[fn] || fn;
		var pos = fn+"("+g_currentStatementInfo.fl+","+g_currentStatementInfo.fc+")";
		Tester.Assert(g_currentStatementInfo.s, false, [ new SeSReportLink(pos), new SeSReportException(e)]);
		Log(pos+": "+e.message);
	} else {
		Tester.Assert(comment, false, new SeSReportException(e));
	}
}

function SeSIncludeInstrumentedJS(fileName, reInclude, isLocal)
{
	if(g_debug)
	{
		if(isLocal)
		{
			return g_helper.IncludeLocal(fileName);
		}
		else if(reInclude)
		{
			return g_helper.Include(fileName);
		} else {
			return g_helper.IncludeOnce(fileName);
		}
	}
	
	if(!reInclude&&g_helper.IsAlreadyIncluded(fileName))
	{
		return "";
	}
	
	// Return instrumented verison of file, ready for eval
	var cmd = g_helper.ResolvePath("InstrumentJS/node.exe");
	var inFile = g_helper.ResolvePath(fileName);
	var expFile = g_helper.ResolveEnvironmentVariables(inFile+'.I%THREAD%.js');
	
	if(!reInclude&&!isLocal&&g_helper.IsAlreadyIncluded(expFile))
	{
		return "";
	}
	
	var testDir = g_helper.GetDirectoryName(inFile);
	var ijsDir = g_helper.GetDirectoryName(cmd);
	var cmdLine = '"'+cmd+'" app.js "--in='+inFile+'" "--dir='+testDir+'" "--out='+expFile+'" --callbackName=_$R$_';
	if(l3) Log3("SeSIncludeInstrumentedJS: calling "+cmdLine);
	var exitCode = g_util.Run(cmdLine, ijsDir, -1, true);
	if(exitCode==0)
	{
		var resScript="";
		if(isLocal) 
		{
			resScript =  g_helper.IncludeLocal(expFile);
		} else {
			resScript =  g_helper.Include(expFile);
		}
		g_helper.DeleteFile(expFile);
		return resScript;
	} else {
		Log("Error while trying to instrument: "+fileName+" using plain source");
		return g_helper.Include(fileName);
	}
}

function SeSParseDate(dtstr)
{
    var iso8601extended = /^\d{4}(-\d{2}(-\d{2}([T ]\d{2}(:\d{2}(:\d{2})?)?([,.]\d+)?(Z|[+-]\d{2}(:\d{2})?)?)?)?)?$/;
    var iso8601basic = new RegExp(iso8601extended.source.replace(/[:-]\\d/g, '\\d'));
    var firstNumber = /[^\d]*(\d+)/g;
    function parse_iso8601(s) {
        s = s.replace(/,/g, '.');
        var matches = iso8601extended.exec(s);
        if (matches) {
            s = s.substr(0, 10).replace(/-/g, '') + s.substr(10).replace(/:/g, '');
        }
        matches = iso8601basic.exec(s);
        if (!matches) {
        	var reMsAjax = /^\/Date\((d|-|.*)\)[\/|\\]$/;
            var a = reMsAjax.exec(s);
            if (a) {
                var b = a[1].split(/[-+,.]/);
                return new Date(b[0] ? +b[0] : 0 - +b[1]);
            }
            return null;
        }
        var d = new Date();
        d.setUTCFullYear(toNumber(matches[0].substring(0, 4)));
        d.setUTCMonth(matches[1] ? toNumber(matches[1].substr(0, 2)) - 1 : 0);
        d.setUTCDate(matches[2] ? toNumber(matches[2].substr(0, 2)) : 1);
        var hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
        var fraction = matches[6] ? parseFloat(matches[6]) : 0;
        if (matches[3]) {
            hours = toNumber(matches[3].substr(1, 2));
            if (matches[4]) {
                minutes = toNumber(matches[4].substr(0, 2));
                if (matches[5]) {
                    seconds = toNumber(matches[5].substr(0, 2));
                    milliseconds = 1000 * fraction;
                } else {
                    seconds = 60 * fraction;
                }
            } else {
                minutes = 60 * fraction;
            }
        }
        if (!matches[7]) {
            d.setHours(hours);
            d.setMinutes(minutes);
        } else {
            d.setUTCHours(hours);
            d.setUTCMinutes(minutes);
        }
        d.setUTCSeconds(seconds);
        d.setUTCMilliseconds(milliseconds);
        if (matches[7] && matches[7] != 'Z') {
            var offset = toNumber(matches[7].substr(1, 2)) * 60;
            if (matches[8]) {
                 offset += toNumber(matches[8].substr(0, 2));
            }
            d.setTime(d.getTime() + 60000 * offset * (matches[7].substr(0, 1) == '-' ? 1 : -1));
        }
        return d;
    }
    function toNumber(s) {
        return parseInt(s.replace(/^0+(\d)/, '$1'));
    }
    return parse_iso8601(dtstr);
}

function SeSCompareJsObjects(path, left, right, info, maxDepth, maxDiffs)
{
	var leftChain = [], rightChain = [];
	info = info || { errors: 0, log: "", diffs: [] };
	maxDepth = maxDepth || 100;
	maxDiffs = maxDiffs || 100;

	function arrIndexOf(other)
	{
		for (var i = 0; i < this.length; i++)
		{
			if (this[i] == other)
			{
				return i;
			}
		}
	
		return -1;
	}
  
	leftChain.indexOf = arrIndexOf;
	rightChain.indexOf = arrIndexOf;
	
	function compare2Objects(path, x, y)
	{
		if (info.diffs.length == maxDiffs)
		{
			return;
		}
	
		maxDepth--;
		
		if (maxDepth == 0)
		{
			maxDepth++;
			return;
		}
		
		__compare2Objects(path, x, y);
		
		maxDepth++;
	}
	
	function __pathAppend(path, p)
	{
		if (path == "")
		{
			return p;
		}
		return path + "." + p;
	}

	function __compare2Objects(path, x, y) 
	{
		var p = null;
	
		// remember that NaN === NaN returns false
		// and isNaN(undefined) returns true
		if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number')
		{
			return;
		}
	
		// Compare primitives and functions.     
		// Check if both arguments link to the same object.
		// Especially useful on the step where we compare prototypes
		if (x === y) 
		{
		    return;
		}
	
		// Works in case when functions are created in constructor.
		// Comparing dates is a common scenario. Another built-ins?
		// We can even handle functions passed across iframes
		if ((typeof x === 'function' && typeof y === 'function') ||
			(x instanceof Date && y instanceof Date) ||
			(x instanceof RegExp && y instanceof RegExp) ||
			(x instanceof String && y instanceof String) ||
			(x instanceof Number && y instanceof Number)) 
		{
			var res = x.toString() === y.toString();
			if(!res)
			{
				info.errors++;
				info.diffs.push(path + ": " + x + " != " + y);
			}
			return;
		}
	
		if((""+x).indexOf("/Date(")==0)
		{
			try
			{
				var nx = SeSParseDate(x);
				if(nx!=null) 
				{
					x = nx;
				}
			}
			catch(e) {}
		}
	
		// Only one side is date, another is string
		if(x instanceof Date)
		{
			try
			{
				var yd = SeSParseDate(y);
				var res = x.toString() == yd.toString();
				if(!res)
				{
					info.errors++;
					info.diffs.push(path + ": " + x + " != " + yd);
				}
				return;
			} 
			catch(e) {}
		}
	
		if(y instanceof Date)
		{
			try
			{
				var xd = SeSParseDate(x);
				var res = xd.toString() == y.toString();
				if(!res)
				{
					info.errors++;
					info.diffs.push(path + ": " + xd + " != " + y);
				}
				return;
			}
			catch(e) {}
		}
	
		// Check for infinite linking loops
		if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) 
		{
			info.errors++;
			info.log += path + ": looping detected\n";
			return;
		}
	
		// Quick checking of one object being a subset of another.
		// todo: cache the structure of arguments[0] for performance
		for (p in y) 
		{
			if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) 
			{
				info.errors++;
				info.diffs.push(__pathAppend(path, p) + ": no such property in obj1");
			}
			else if (typeof y[p] !== typeof x[p]) 
			{
				info.errors++;
				info.diffs.push(__pathAppend(path, p) + ": different types: " + (typeof x[p]) + " != " + (typeof(y[p])));
			}
			
			if (info.diffs.length == maxDiffs)
			{
				break;
			}				
		}
		
		if (info.diffs.length == maxDiffs)
		{
			return;
		}	
		
		for (p in x) 
		{
			if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) 
			{
				info.errors++;
				info.diffs.push(__pathAppend(path, p) + ": no such property in obj2");
			}
			else if (typeof y[p] !== typeof x[p]) 
			{
				info.errors++;
				info.diffs.push(__pathAppend(path, p) + ": different types: " + (typeof x[p]) + " != " + (typeof(y[p])));
			}
			else
			{
				switch (typeof x[p]) 
				{
					case 'object':
					case 'function':
						leftChain.push(x);
						rightChain.push(y);
						var p1 = __pathAppend(path, p);
						if("length" in x)
						{
							p1 = path + "[" + p + "]";
						}
						
						compare2Objects (p1, x[p], y[p]);
						
						leftChain.pop();
						rightChain.pop();
						break;
					
					default:
						if (x[p] !== y[p]) 
						{
							info.errors++;
							var valuePath = __pathAppend(path, p);
							if ("length" in x)
							{
								valuePath = path + "[" + p + "]";
							}
							info.diffs.push(valuePath + ": " + x[p] + " != " + y[p]);
						}
						break;
				}
			}
			
			if (info.diffs.length == maxDiffs)
			{
				break;
			}			
		}
		return;
	}
	
	if (typeof left != typeof right) 
	{
		info.errors++;
		info.diffs.push("different types: " + (typeof left) + " != " + (typeof right));
	    return false;
	}	
	
	if ((typeof left != "object" && typeof right != "object")
		&&
		(typeof left != "function" && typeof right != "function"))
	{
		// compare primitive types
		if (left != right)
		{
			info.errors++;
			info.diffs.push(left + " != " + right);
		}
		
	}
	else
	{
		compare2Objects(path, left, right);
	}
	
	return info.errors == 0;
}
